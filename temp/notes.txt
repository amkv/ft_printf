/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   notes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: akalmyko <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/11/25 15:31:08 by akalmyko          #+#    #+#             */
/*   Updated: 2016/11/25 15:31:10 by akalmyko         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "libftprintf.h"


int 		ft_numlen(int num)
{
	int 	len;

	len = 0;
	if (num < 0)
	{
		len++;
		num = -num;
	}
	while (num != 0)
	{
		num /= 10;
		len++;
	}
	return (len);
}

int 				ft_printf(const char * restrict format, ...)
{
	va_list 		ap;
//	va_list 		tmp;
	int				counter;
	char			*temp;
	int				num;
//	unsigned int	unum;
//	unsigned char	*uchar;

//	printf("%s", format);

	counter = 0;
	if (*format == '\0')
		return (counter);
	va_start(ap, format);
//	tmp = ap;
//	va_copy(tmp, ap);

//	printf("%p", va_arg(ap, char *));
//	printf("\n");

//	printf("%s", (char*)ap->reg_save_area);
// 	printf("%p", (char*)ap->next);

//	printf("%s", va_arg(ap, char *));
//	printf("\n");
//	printf("%s", va_arg(ap, char *));
//	printf("\n");
//	printf("%s", va_arg(ap, char *));
//	printf("\n");
//	printf("%s", va_arg(ap, char *));
//	printf("\n");
//	while ((va_arg(tmp)) != NULL)
//		counter++;
//
////
	while (*format != '\0')
	{
		*/
/* печатаю символы идущие до символа % , сдвигаюсь вправо по строке*//*

		while((*format != '%') && *format != '\0')
		{
			ft_putchar(*format++);
			counter++;
		}
		*/
/* если строка закончилась, то выхожу из функции *//*

		if (*format == '\0')
			break;
		*/
/* если нахожу символ % обрабатываю второй символ $ - печатая его, двигаюсь вправо *//*

		if (*format == '%')
			format++;
		if (*format == '%')
		{
			ft_putchar('%');
			counter++;
		}
		*/
/* начинаю проверку на символы *//*

		*/
/* если это строка *//*

		if (*format == 's')
		{
			temp = (va_arg(ap, char *));
			counter = counter + (int)ft_strlen(temp);
			ft_putstr(temp);
		}
			*/
/* если это номер *//*

		else if (*format == 'd')
		{
			num = va_arg(ap, int);
			counter = counter + ft_numlen(num);
			ft_putnbr(num);
		}
			*/
/* если это символ *//*

		else if (*format == 'c')
		{
			ft_putchar(va_arg(ap, int));
			counter++;
		}
		*/
/* если это unsigned int как шестнадцатиричное число *//*

//		else if (*format == 'x')
//		{
//			uchar = va_arg(ap, unsigned char *);
//			unum = ft_atoi_base(uchar, 16);
//			uchar = itoa(unum);
//			counter = counter + (int)ft_strlen(uchar);
//			ft_putstr(uchar);
//		}
		format++;
	}
	va_end(ap);
	return (counter);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	while (*format != '\0')
	{
		*/
/* печатаю символы идущие до символа % , сдвигаюсь вправо по строке*//*

		while((*format != '%') && *format != '\0')
		{
			ft_putchar(*format++);
			counter++;
		}
		*/
/* если строка закончилась, то выхожу из функции *//*

		if (*format == '\0')
			break;
		*/
/* если нахожу символ % обрабатываю второй символ $ - печатая его, двигаюсь вправо *//*

		if (*format == '%')
			format++;
		if (*format == '%')
		{
			ft_putchar('%');
			counter++;
		}
		*/
/* начинаю проверку на символы *//*

		*/
/* если это строка *//*

		if (*format == 's')
		{
			temp = (va_arg(ap, char *));
			counter = counter + (int)ft_strlen(temp);
			ft_putstr(temp);
		}
		*/
/* если это номер *//*

		else if (*format == 'd')
		{
			num = va_arg(ap, int);
			counter = counter + ft_numlen(num);
			ft_putnbr(num);
		}
		*/
/* если это символ *//*

		else if (*format == 'c')
		{
			ft_putchar(va_arg(ap, int));
			counter++;
		}
		*/
/* если это unsigned int как шестнадцатиричное число *//*

//		else if (*format == 'x')
//		{
//			uchar = va_arg(ap, unsigned char *);
//			unum = ft_atoi_base(uchar, 16);
//			uchar = itoa(unum);
//			counter = counter + (int)ft_strlen(uchar);
//			ft_putstr(uchar);
//		}
		format++;
	}
	va_end(ap);
	return (counter);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*/
/* main tests *//*


//	mr = ft_printf("");
//	printf("\n");
//	or =    printf("");
//	ft_p(mr, or);
//
//	mr = ft_printf("a");
//	printf("\n");
//	or =    printf("a");
//	ft_p(mr, or);
//
//	mr = ft_printf("1");
//	printf("\n");
//	or =    printf("2");
//	ft_p(mr, or);
//
//	mr = ft_printf("a1");
//	printf("\n");
//	or =    printf("a1");
//	ft_p(mr, or);
//
//	mr = ft_printf("1a");
//	printf("\n");
//	or =    printf("1a");
//	ft_p(mr, or);
//
//	mr = ft_printf(" ");
//	printf("\n");
//	or =    printf(" ");
//	ft_p(mr, or);
//
//	mr = ft_printf("\tt");
//	printf("\n");
//	or =    printf("\tt");
//	ft_p(mr, or);
//
//	mr = ft_printf("number%d", 5);
//	printf("\n");
//	or =    printf("number%d", 5);
//	ft_p(mr, or);
//
//	mr = ft_printf("number/%d", 6);
//	printf("\n");
//	or =    printf("number/%d", 6);
//	ft_p(mr, or);

//	mr = ft_printf("number\%%d", 7);
//	printf("\n");
//	or =    printf("number\%%d", 7);
//	ft_p(mr, or);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

t_com		*ft_tcom_new(char type, char *command)
{
	t_com	*new;
	char	*str_ptr;
//	size_t 	len;

	if (!(new = (t_com*)malloc(sizeof(t_com) * 1)))
		return (NULL);
//	len = ft_strlen(command);
//	if (!(str_ptr = (char*)malloc(sizeof(char) * (len + 1))))
//		return (NULL);
//	ft_memcpy(str_ptr, command, len);
//	*(str_ptr + len) = '\0';
	str_ptr = ft_strdup(command);
	new->type = type;
	new->command = str_ptr;
	new->len = -1;
	new->next = NULL;
	return (new);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*/
/*

#include "../libftprintf.h"

int ft_parser(const char *format, t_com **list)
{
	int 	arg;											// возвращаемое количество аргументов
	size_t 	len;											// темповая переменная для длины слова
	size_t 	start;											// темповая переменная для начала слова
	size_t 	counter;										// счетчик-переключатель для определения %
	char	sign;											// знак для записи в листы % или .
	char	*format_copy;									// копия format для отсчета от начала слова
	char	*holder;										// темповая переменная для malloc, для вырезаемого слова
	t_com	*new;											// лист t_com для сохранения переменной

	arg = 0;												// инициализация переменных
	start = 0;
	counter = 0;
	format_copy = (char*)format;
	*list = NULL;

	while (*format != '\0') 								// иду пока не достигну конца строки с аргументами
	{
		len = 0;											// устанавливаю длину слова 0
		holder = NULL;										// устанавливаю/обнуляю holder
		if (*format == '%')
		{
			counter++;
			format++;											// сдвигаю поинтер format
		}
		while (*format != '%' && *format != '\0')			// циклирую пока не дойду до знака % или не дойду до конца стринга
		{
			len++;											// увеличиваю счетчик длины слова
			format++;										// сдвигаю поинтер стринга
		}
		if (*format == '\0' && len == 0)					// проверяю на выходе, длину слова и дошел ли loop до конца
			return (arg);									// тогда возвращаю количество аргументов: 0
		holder = (char*)malloc(sizeof(char) * len + 1);		// инициализирую holder с длиной слова len + 1
		if (counter > 0)									// если первый проход, то равен нулю, впоследствии определяет % и правильно копирует из format_copy
		{
			start++; 		//len++;						// сдвигаю индекс при копировании format_copy, чтобы исключить знак %
			sign = '%';										// устанавливаю переменной sign % - для записи в лист
		}
		else
			sign = '.';										// если % не было найдено (просто стринг), то устанаваливаю знак для обычной печати
		holder = ft_strnncpy(holder, format_copy, start, len); // возможно нужно использовать memcpy
		start += len;										// добавляю к переменной start новую длину слова, для корректного вырезания в сл. цикле
		*(holder + len) = '\0';								// нуль-терминирую стринг
		new = ft_tcom_new(sign, holder);					// создаю новый лист t_com new
		if (*list == NULL)									// если это первый лист
			*list = new;									// то первым листом становится первая переменная new
		else
			ft_tcom_add(*&list, new);						// если лист уже не NULL, добавляю к нему новый лист
		free(holder);										// очищаю выделенную память для holder
		arg++;												// увеличиваю счетчик аргументов
		counter = 0;										// обнуляю тумблерную переменную counter
	}
	return (arg);											// возвращаю количество аргументов, распилинных и поделенных
}

//static void ft_get_argument(t_list *list)
//{
//
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//int			ft_parser(const char *format, t_com **list)
//{
//	int		arg;
//	size_t	len;
//	size_t	beg;
//	size_t	yn;
//	char	*copy;
//	char	*holder;
//
//
//	arg = 0;
//	beg = 0;
//	copy = (char*)format;
//	while (*copy != '\0')
//	{
//		holder = NULL;
//		ft_checker(&copy, &yn, &len, &beg);
//		if (*copy == '\0' && len == 0)
//			return (arg);
//		ft_memnncpy((holder = ft_strnew(len + 1)), format, beg, len);
//		beg += len;
//		ft_tcom_list(*&list, yn, holder);
//		arg++;
//	}
//	ft_tcom_revert(*&list);
//	return (arg);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*/
/*
		str = arg->data;
		if (ft_check_command(*str) == 0) {
			counter = counter + (int) ft_strlen(str);
			ft_putstr(str);
		} else
			counter += ft_processing(str, va_arg(ap, void *));
*//*


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//static size_t	ft_switcher(t_com **list, void *something)
//{
//	t_com		*copy;
//	size_t 		characters;
//
//	copy = *list;
//	characters = 0;
//	if ((copy->type) != '%')
//	{
//		ft_putstr(copy->command);
//		characters = copy->len;
//	}
//	else
//	{
//		characters = ft_handler(*&list, something);
//		if (characters == 0)
//			return (0);
//	}
//	return (characters);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//static void	ft_get_arg(char **str, size_t *beg, size_t *yn, size_t *len)
//{
//	char 	*copy;
//
//
//	*yn = 0;
//	*len = 0;
//	if (**str == '%')
//	{
//		(*yn)++;
//		(*str)++;
//	}
//	copy = *str;
//	if (**str == '%')
//		(*len) = 1;
//	else
//		while (*copy != '\0')
//		{
//			if (*copy == '%'  && *(copy + 1) == '%')
//				copy++;
//			if (*copy == '%'  && *(copy + 1) != '%' && *(copy + 1) != '\0')
//				break;
//			(*len)++;
//			copy++;
//		}
//	if (*yn > 0)
//		(*beg)++;
//	*str = copy;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//static void	ft_check_patterns(t_com **com, char **holder, size_t *yn)
//{
//	char	*copy;
//	char 	*new;
//	char 	*hold;
//
//	if (*yn == 0)
//		return ;
//	copy = *holder;
//	if (*copy == '%')
//		*yn = 0;
//	if (ft_strlen(copy) == 1)
//		return ;
//	if (ft_is_modifier(*copy) == 1)
//	{
//		ft_memcpy((hold = ft_strnew(2)), copy, 1);
//		ft_tcom_list(*&com, *yn, hold);
//	}
//	new = ft_strdup(++copy);
//	free(*holder);
//	*holder = new;
//	*yn = 0;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

char 			*ft_add_spaces(char *str, long int width)
{
//	long int	len;
//	long int 	spaces;
//	char 		*temp;
//	char 		*result;
//	long int 	index;

//	len = ft_strlen(str);
//	if (width > 0)
//	{
//		if (len >= width)
//			return (ft_strdup(str));
//	}
//	else
//		width = -(width);
//	spaces = width - len;
//	temp = ft_strnew((size_t)spaces + 1);
//	if (!temp)
//		return (NULL);
//	index = 0;
//	while (index < spaces)
//		temp[index++] = ' ';
//	result = ft_strjoin(temp, str);
//	if (!result)
//		return (NULL);
//	free(temp);
//	return (result);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//static size_t	ft_handler(t_com **com, va_list ap)
//{
//	char			*modifier;
//	union u_type	type;
//
//	modifier = (*com)->modifier;
//
//	ft_pre_print_width(*&com);
//	return ((*com)->len);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//char		*ft_pat_width(char **holder)
//{
//	char 	*copy;
//	char 	*result;
//	char 	*temp;
//	size_t 	len;
//
//	copy = *holder;
//	len = 0;
//	while (ft_isdigit(*copy) && *copy && ft_is_modifier(*copy) == 0)
//	{
//		copy++;
//		len++;
//	}
//	if (len == 0)
//		return (NULL);
//	else
//	{
//		result = ft_strnew(len + 1);
//		ft_memcpy(result, *holder, len);
//	}
//	temp = ft_strdel_begn(*holder, len);
//	free(*holder);
//	*holder = NULL;
//	*holder = temp;
//	return (result);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void	ft_check_patterns(t_com **com, size_t *yn)
{
	char 	*holder;
	char 	*temp;

//	holder = (*com)->scroll;
	holder = ft_strdup((*com)->scroll);
	temp = ft_strdup((*com)->scroll);
	if (*yn == 0 || ft_pat_one(*&com) == 1)
		return ;
	(*com)->param = ft_pat_parameter(&holder);
//	(*com)->flag = ft_is_flags(&holder);
	(*com)->width = ft_pat_width(&holder);
//	(*com)->precision = ft_is_precision(&holder);
//	(*com)->length =  ft_is_lenght(&holder);
	(*com)->modifier = ft_pat_modifier(&holder);

	free((*com)->scroll);
	(*com)->scroll = NULL;
	(*com)->len = 0;
//	if (holder && *holder == '%' && ft_strlen(holder) == 1)
//	{
//		if ((*com)->width)
//			(*com)->scroll = ft_add_spaces(holder, (*com)->width);
//		else
//			(*com)->scroll = holder;
//		(*com)->len = ft_strlen((*com)->scroll);
//		return ;
//	}
	if (holder && ft_strcmp(temp, holder) != 0)
		ft_tcom_list(*&com, 0, holder);
	free(temp);
//	else
//	{
//		(*com)->scroll = NULL;
//		(*com)->len = 0;
//	}
//	(*com)->scroll = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//void	ft_check_patterns(t_com **com, size_t *yn, )
//{
//	char 	*holder;
//	char 	*temp;
//
//	if (*yn == 0 || ft_pat_one(*&com) == 1)
//		return ;
//	holder = ft_strdup((*com)->scroll);
//	temp = ft_strdup((*com)->scroll);
//
//	free((*com)->scroll);
//	(*com)->scroll = NULL;
//	(*com)->len = 0;
//
//	(*com)->param = ft_pat_parameter(&holder);
//	(*com)->flag = ft_pat_flags(&holder);
//	(*com)->width = ft_pat_width(&holder);
//	(*com)->precision = ft_pat_precision(&holder);
////	(*com)->length =  ft_is_lenght(&holder);
//	(*com)->modifier = ft_pat_modifier(&holder);
//	if ((*com)->modifier == NULL)
//		(*com)->type = '.';
//
//	if (holder && ft_strcmp(temp, holder) != 0) // ||
//		ft_tcom_list(*&com, 0, holder);
//	free(temp);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//static int 	ft_check_modifier(const char *str)
//{
//	while (*str)
//	{
//		if (ft_is_modifier(*str) == 1)
//			return (1);
//		str++;
//	}
//	return (0);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void		ft_check_patterns(t_com **com, size_t *yn, char **holder, size_t *argc)
{
	char	*copy; //переменная для сравнения начального состояния *holder и конечного, сохраняю адрес на первую ячейку в памяти
	t_com	*fresh; // новый чистый лист для манипуляций

	// создаю новый чистый лист
	fresh = ft_tcom_new();
	// если модификаторов во время распиливания стринга не обнаружилось
	// создаю простой лист для печати
	if (*yn == 0)
	{
		fresh->scroll = *holder;
		fresh->len = ft_strlen(*holder);
		ft_tcom_list(*&com, fresh);
		return ;
	}
	copy = ft_strdup(*holder);
	// заношу все данные в лист
	(fresh)->param = ft_pat_parameter(*&holder);
	(fresh)->flag = ft_pat_flags(*&holder);
	(fresh)->width = ft_pat_width(*&holder);
//	if ((fresh)->width == '*')
//	{
//		ft_tcom_list(*&com, ft_tcom_new());
//		(*com)->modifier = ft_strdup("d");
//		(*com)->type = '%';
//	}
	(fresh)->precision = ft_pat_precision(*&holder);
	(fresh)->length =  ft_pat_length(*&holder);
	(fresh)->modifier = ft_pat_modifier(*&holder);
	if ((fresh)->modifier == NULL && *holder)
	{
		(fresh)->scroll = ft_strdup(*holder); // добавить проверку на нулевой холдер
		(fresh)->len = ft_strlen((fresh)->scroll);
	}
	else
	{
		(fresh)->type = '%';
		(*argc)++;
	}
	// добавляю (сохраняю обработанный лист) лист в цепочку
	ft_tcom_list(*&com, fresh);
	// проверяю остаток в *holder
	// если *holder весь записался в лист, возвращаюсь из функции
	if (*holder == NULL)
	{
		free(copy);
		return ;
	}
	// проверяю не нулевой остаток
	// все, что не нашлось по паттернам записываю в новый лист, как текст, для простой печати
	if (ft_strcmp(copy, *holder) != 0)
	{
		fresh = ft_tcom_new();
		fresh->scroll = ft_strdup(*holder);
		fresh->len = ft_strlen(fresh->scroll);
		ft_tcom_list(*&com, fresh);
	}
	free(copy);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//char			*ft_pat_precision(char **holder)
//{
//	char		*new_holder;
//	char		*precision;
//	char 		*copy;
//
//	if (!(*holder))
//		return (NULL);
//	if (**holder == '.')
//	{
//		copy = *holder;
//		if (*(copy + 1) != '\0')
//			copy++;
//		if (ft_isdigit(*copy) == 1)
//		{
//			precision = ft_itoa(ft_atoi(copy));
//			new_holder = ft_strdel_begn(*holder, ft_strlen(precision) + 1);
//			ft_free_and_set(*&holder, &new_holder);
//			return (precision);
//		}
//		else if (*copy== '*')
//		{
//			precision = ft_strdup("*");
//			new_holder = ft_strdel_begn(*holder, 1);
//			ft_free_and_set(*&holder, &new_holder);
//			return (precision);
//		}
//	}
//	return (NULL);
//}

//char			*ft_pat_precision(char **holder)
//{
//	char		*new_holder;
//	char		*precision;
//
//	if (!(*holder))
//		return (NULL);
//	precision = *holder;
//	if (**holder == '.')
//	{
//		new_holder = *holder;
//		if (*(new_holder + 1) != '\0')
//			new_holder++;
//		precision = ft_itoa(ft_atoi(new_holder));
//		new_holder = ft_strdel_begn(*holder, ft_strlen(precision) + 1);
//	}
//	else if (**holder == '*')
//	{
//		precision = ft_strdup("*");
//		new_holder = ft_strdel_begn(*holder, 1);
//	}
//	else
//		return (NULL);
//	ft_free_and_set(*&holder, &new_holder);
//	return (precision);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



*/
